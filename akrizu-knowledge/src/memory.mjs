/**
 * Senior Dev Mind â€” Conversation Memory Auto-Append
 * Appends structured conversation summaries to .agent/memory/conversation-summaries.md
 * then auto re-ingests that file into Qdrant so it's searchable via RAG.
 *
 * Usage (CLI):
 *   node src/memory.mjs --task "build login page" --summary "Used MVVM, created useLogin.ts, added Zod schema"
 *   node src/memory.mjs --task "debug booking API" --summary "Fixed 401 on /api/bookings/dates by whitelisting in proxy.ts"
 *
 * Usage (API):
 *   POST /memory/save { task, summary, tags? }
 */

import { appendFileSync, existsSync, mkdirSync } from "fs";
import { resolve, dirname } from "path";
import { fileURLToPath } from "url";
import { CONFIG } from "./config.mjs";
import { embed } from "./embedder.mjs";
import { upsertPoints, scrollAll } from "./qdrant.mjs";

const __dirname = dirname(fileURLToPath(import.meta.url));

// â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MEMORY_FILE = resolve(
  CONFIG.knowledgeBasePath,
  "memory",
  "conversation-summaries.md"
);

// â”€â”€â”€ Format Summary Entry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Formats a summary entry as a markdown section.
 * @param {string} task - What the task was
 * @param {string|string[]} summary - Key decisions/outcomes (string or bullet array)
 * @param {string[]} [tags=[]] - Optional tags for better retrieval
 * @returns {string}
 */
export function formatSummaryEntry(task, summary, tags = []) {
  const date = new Date().toISOString().split("T")[0];
  const time = new Date().toLocaleTimeString("en-PH", { hour12: false });
  const bullets = Array.isArray(summary)
    ? summary.map((s) => `- ${s}`).join("\n")
    : `- ${summary}`;
  const tagLine = tags.length > 0 ? `**Tags**: ${tags.join(", ")}\n` : "";

  return `\n## [${date} ${time}] ${task}\n${tagLine}${bullets}\n`;
}

// â”€â”€â”€ Append to Memory File â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Appends a summary entry to conversation-summaries.md.
 * Creates the file and directory if they don't exist.
 * @param {string} task
 * @param {string|string[]} summary
 * @param {string[]} [tags=[]]
 */
export function appendSummary(task, summary, tags = []) {
  const dir = dirname(MEMORY_FILE);

  // Ensure directory exists
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }

  // Create file with header if it doesn't exist
  if (!existsSync(MEMORY_FILE)) {
    appendFileSync(
      MEMORY_FILE,
      "# Conversation Summaries\nAuto-generated by Senior Dev Mind RAG memory hook.\n",
      "utf-8"
    );
    console.log("ğŸ“„ Created conversation-summaries.md");
  }

  const entry = formatSummaryEntry(task, summary, tags);
  appendFileSync(MEMORY_FILE, entry, "utf-8");
  console.log(`âœ… Appended summary for: "${task}"`);
}

// â”€â”€â”€ Re-ingest Memory File into Qdrant â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Embeds and upserts the latest summary entry into Qdrant.
 * Uses a lightweight single-entry upsert instead of full re-ingest.
 * @param {string} task
 * @param {string|string[]} summary
 * @param {string[]} [tags=[]]
 */
export async function ingestSummary(task, summary, tags = []) {
  const content = formatSummaryEntry(task, summary, tags).trim();
  const relPath = "memory/conversation-summaries.md";

  // Get current max ID to avoid collision
  const existing = await scrollAll({ category: "memory", limit: 500 });
  const maxId = existing.reduce((max, p) => Math.max(max, p.id || 0), 0);
  const newId = maxId + 1;

  // Embed the summary content
  const vector = await embed(content);

  // Upsert into Qdrant
  await upsertPoints([
    {
      id: newId,
      vector,
      payload: {
        content,
        source_file: relPath,
        section: task,
        category: "memory",
        tags: tags.length > 0 ? tags : ["memory", "conversation"],
        priority: "normal",
        auto_generated: true,
        created_at: new Date().toISOString(),
      },
    },
  ]);

  console.log(`ğŸ”® Ingested summary into Qdrant (id: ${newId})`);
}

// â”€â”€â”€ Main Export: Save Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Full pipeline: append to file + ingest into Qdrant.
 * @param {string} task - What was done
 * @param {string|string[]} summary - Key decisions/outcomes
 * @param {string[]} [tags=[]] - Optional tags
 */
export async function saveMemory(task, summary, tags = []) {
  if (!task || !summary) {
    throw new Error("task and summary are required");
  }

  // Step 1 â€” Append to markdown file (persistent log)
  appendSummary(task, summary, tags);

  // Step 2 â€” Ingest into Qdrant (searchable via RAG)
  await ingestSummary(task, summary, tags);

  console.log(`\nğŸ§  Memory saved and searchable via RAG for: "${task}"`);
}

// â”€â”€â”€ CLI Mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function runCLI() {
  const args = process.argv.slice(2);
  const get = (flag) => {
    const i = args.indexOf(flag);
    return i !== -1 ? args[i + 1] : null;
  };

  const task = get("--task");
  const summaryRaw = get("--summary");
  const tagsRaw = get("--tags");

  if (!task || !summaryRaw) {
    console.error("Usage: node src/memory.mjs --task \"task name\" --summary \"what was done\" [--tags \"tag1,tag2\"]");
    process.exit(1);
  }

  const summary = summaryRaw.includes(",")
    ? summaryRaw.split(",").map((s) => s.trim())
    : summaryRaw;

  const tags = tagsRaw ? tagsRaw.split(",").map((t) => t.trim()) : [];

  await saveMemory(task, summary, tags);
}

// Run CLI if called directly
if (process.argv[1] === fileURLToPath(import.meta.url)) {
  runCLI().catch((err) => {
    console.error("ğŸ’¥ Memory save failed:", err.message);
    process.exit(1);
  });
}
